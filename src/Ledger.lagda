\documentclass{article}
\usepackage{unicode-math}
\setsansfont{XITSMath-Regular.otf}[
Path = /Library/Fonts/ ,
]

\usepackage{newunicodechar}
\newunicodechar{ᵇ}{\ensuremath{^b}}
\newunicodechar{₁}{\ensuremath{_1}}
\newunicodechar{₂}{\ensuremath{_2}}

\usepackage{float}
\floatstyle{boxed} 
\restylefloat{figure}

\usepackage{iohk}

\usepackage[hidelinks]{hyperref}
\usepackage[links]{agda}

\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\Tx}{\type{Tx}}
\newcommand{\Ix}{\type{Ix}}
\newcommand{\TxId}{\type{TxId}}
\newcommand{\Addr}{\type{Addr}}
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\Coin}{\type{Coin}}
\newcommand{\TxIn}{\type{TxIn}}
\newcommand{\TxOut}{\type{TxOut}}
\newcommand{\UTxOEnv}{\type{UTxOEnv}}
\newcommand{\UTxOState}{\ensuremath{\type{UTxOState}}}

%%
%% Functions
%%
\newcommand{\txins}[1]{\fun{txins}~ \var{#1}}
\newcommand{\txouts}[1]{\fun{txouts}~ \var{#1}}
\newcommand{\txid}[1]{\fun{txid}~ \var{#1}}
\newcommand{\outs}[1]{\fun{outs}~ \var{#1}}
\newcommand{\balance}[1]{\fun{balance}~ \var{#1}}
\newcommand{\txfee}[1]{\fun{txfee}~ \var{#1}}

\newcommand{\wcard}[0]{\rule[-.5mm]{2mm}{.2mm}}
\newcommand{\leteq}{\ensuremath{\mathrel{\mathop:}=}}

\newtheorem{property}{Property}[section]


\begin{document}

\begin{code}[hide]

{-# OPTIONS --safe #-}

open import Data.List using (List; any; foldr; sum; mapMaybe)
open import Data.List.Relation.Unary.All using (All; all?)
open import Data.Nat using (ℕ; _+_; _≤_; _≤?_)
open import Data.Nat.Properties using (+-0-commutativeMonoid; +-0-monoid; +-comm)
open import Data.Maybe
import Data.Maybe.Properties
open import Data.Maybe.Relation.Unary.Any using (dec)
open import Data.Product
open import Data.Product.Properties
open import Data.Bool using (Bool; if_then_else_; _∧_; true; false)
open import Data.Unit using (tt)
open import Data.Empty
open import Data.List.Membership.Propositional

open import Algebra using (CommutativeMonoid)
open import Function hiding (id; _↪_) renaming (_↣_ to _↪_)
import Function.Related.Propositional as P

open import Relation.Nullary
open import Relation.Nullary.Decidable
open import Relation.Nullary.Product
open import Relation.Binary
open import Relation.Binary.PropositionalEquality

open import FinMap renaming (FinMap to _↦_)
open import FinSet hiding (∅) renaming (FinSet to ℙ_)
open import DecEq
open import FinSet.Properties.Equality
open import FinSet.Properties
open import Tactic.MonoidSolver
open import TacticReasoning

module Ledger (
\end{code}

\section{Transactions}
\label{sec:transactions}

Transactions are defined in Figure~\ref{fig:defs:utxo-shelley}.
A transaction is made up of three pieces:

\begin{itemize}
  \item A set of transaction inputs.
    This derived type identifies an output from a previous transaction.
    It consists of a transaction id and an index to uniquely identify the output.
  \item An indexed collection of transaction outputs.
    The $\TxOut$ type is an address paired with a coin value.
  \item A transaction fee. This value will be added to the fee pot.
\end{itemize}

Finally, $\fun{txid}$ computes the transaction id of a given transaction.
This function must produce a unique id for each unique transaction body.
\textbf{We assume that} $\fun{txid}$ \textbf{is injective.}

\AgdaTarget{Ix, TxId, Addr, Coin, TxIn, TxOut, UTxO, Tx, txins, txouts, txfee, txid}
\begin{figure*}[h]
\emph{Abstract types}
\begin{code}
  Ix           -- index
  TxId         -- transaction id
  Addr         -- address
\end{code}
\emph{Derived types}
\begin{code}[hide]
  : Set) {{_ : DecEq TxId}} {{_ : DecEq Ix}} {{_ : DecEq Addr}} where
_≤ᵇ_ : ℕ → ℕ → Bool
n ≤ᵇ m = ⌊ n ≤? m ⌋

_⟨$⟩_ : {A B : Set} → A ↪ B → A → B
_⟨$⟩_ = P.⇒→ {k = P.injection}

instance
  _ = +-0-commutativeMonoid

Coin TxIn TxOut UTxO : Set
\end{code}
\begin{code}
Coin = ℕ
TxIn = TxId × Ix
TxOut = Addr × Coin
UTxO = TxIn ↦ TxOut
\end{code}
\emph{Transaction types}
\begin{code}
record Tx : Set where
  field
    txins : ℙ TxIn
    txouts : Ix ↦ TxOut
    txfee : Coin
\end{code}
\emph{Abstract functions}
\begin{code}[hide]
open Tx
module _ (
\end{code}
\begin{code}
  txid : Tx ↪ TxId -- an injective function
\end{code}
\begin{code}[hide]
  ) where
\end{code}
\caption{Definitions used in the UTxO transition system}
\label{fig:defs:utxo-shelley}
\end{figure*}

\section{UTxO}
\label{sec:utxo}

Figure~\ref{fig:functions:utxo} defines functions needed for the UTxO transition system.
Figure~\ref{fig:ts-types:utxo-shelley} defines the types needed for the UTxO transition system.
The UTxO transition system is given in Figure~\ref{fig:rules:utxo-shelley}.

\begin{itemize}

  \item
    The function $\fun{outs}$ creates the unspent outputs generated by a transaction.
    It maps the transaction id and output index to the output.

  \item
    The $\fun{balance}$ function calculates sum total of all the coin in a given UTxO.
\end{itemize}

\AgdaTarget{outs, balance}
\begin{figure*}[h]
\begin{code}
  outs : Tx → UTxO
  outs tx = mapKeys (txid ⟨$⟩ tx ,_) $ txouts tx
  
  balance : UTxO → Coin
  balance utxo = Σ[ v ← utxo ] proj₂ (proj₂ v)
\end{code}
\caption{Functions used in UTxO rules}
\label{fig:functions:utxo}
\end{figure*}

\AgdaTarget{UTxOEnv, UTxOState, \_⊢\_⇀⦇\_,UTXO⦈\_}
\begin{figure*}[h]
\emph{UTxO environment}
\begin{code}[hide]
  UTxOEnv UTxOState : Set
\end{code}
\begin{code}
  UTxOEnv = Coin -- minimum fee
\end{code}
\emph{UTxO states}
\begin{code}
  UTxOState = UTxO -- UTxO
            × Coin -- fee pot
\end{code}
\emph{UTxO transitions}

\begin{code}[hide]
  variable
    tx : Tx
    utxo utxo' utxo1 utxo2 : UTxO
    minFee fee fee' fees fees' : Coin
    utxoState utxoState' utxoState1 utxoState2 : UTxOState
    utxoEnv : UTxOEnv
  
  ⟦_⟧ : {A : Set} → A → A
  ⟦_⟧ = Function.id
  
  data
\end{code}
\begin{code}
    _⊢_⇀⦇_,UTXO⦈_ : UTxOEnv → UTxOState → Tx → UTxOState → Set
\end{code}
\caption{UTxO transition-system types}
\label{fig:ts-types:utxo-shelley}
\end{figure*}

\begin{figure*}[h]
\begin{code}[hide]
  infix 0 _────────────────────────────────_
  _────────────────────────────────_ : Set → Set → Set
  A ──────────────────────────────── B = A → B

  data _⊢_⇀⦇_,UTXO⦈_ where
\end{code}
\begin{code}
    UTXO-inductive :
        txins tx ⊆ dom utxo
      → let f = txfee tx in minFee ≤ f
      → balance (txins tx ◃ utxo) ≡ balance (outs tx) + f
      ────────────────────────────────
      minFee
      ⊢ ⟦ utxo , fees ⟧
      ⇀⦇ tx ,UTXO⦈
        ⟦ (txins tx ⋪ utxo) ∪ outs tx , fees + txfee tx ⟧
\end{code}
\caption{UTXO inference rules}
\label{fig:rules:utxo-shelley}
\end{figure*}

\begin{code}[hide]
  balance-∪ : utxo ∩ utxo' ≡ᵉ ∅ → balance (utxo ∪ utxo') ≡ balance utxo + balance utxo'
  balance-∪ {utxo} {utxo'} = indexedSum-∪ {s = utxo} {s' = utxo'}
  
  balance-cong : utxo ≡ᵉ utxo' → balance utxo ≡ balance utxo'
  balance-cong {utxo} {utxo'} =  indexedSum-cong {s = utxo} {s' = utxo'}
  
  open TacticReasoning.≡-Reasoning {_} {ℕ} (solve-macro (quoteTerm +-0-monoid))
\end{code}

\begin{property}[\textbf{Preserve Balance}]
For all $\var{minFee}\in\UTxOEnv$, $\var{utxo},\var{utxo'}\in\UTxOState$, and $\var{tx}\in\Tx$, if
\begin{code}[hide]
  pov :
\end{code}
\begin{code}[inline*]
    utxo ∩ outs tx ≡ ∅
\end{code}
and
\begin{code}[hide]
    →
\end{code}
\begin{code}[inline*]
        minFee ⊢ (utxo , fee) ⇀⦇ tx ,UTXO⦈ (utxo' , fee')
\end{code}
then
\begin{code}[hide]
    →
\end{code}
\begin{code}
        balance utxo + fee ≡ balance utxo' + fee'
\end{code}
\begin{code}[hide]
  pov {utxo} {tx} {_} {fee} h' (UTXO-inductive x x₁ x₂) =
    let
      h : utxo ∩ outs tx ≡ᵉ ∅
      h = subst ((utxo ∩ outs tx) ≡ᵉ_) h' (IsEquivalence.refl ≡ᵉ-isEquivalence {utxo ∩ outs tx})
    
      balance-eq : balance utxo ≡ balance ((txins tx ⋪ utxo) ∪ outs tx) + txfee tx
      balance-eq = begin
        balance utxo
          ≡˘⟨ balance-cong {utxo = (txins tx ⋪ utxo) ∪ (txins tx ◃ utxo)} {utxo' = utxo} (dom-res-ex-∪ (txins tx) utxo) ⟩
        balance ((txins tx ⋪ utxo) ∪ (txins tx ◃ utxo))
          ≡⟨ balance-∪ {txins tx ⋪ utxo} {txins tx ◃ utxo} (dom-res-ex-∩ (txins tx) utxo) ⟩
        balance (txins tx ⋪ utxo) + balance (txins tx ◃ utxo)
          ≡⟨ cong (balance (txins tx ⋪ utxo) +_) x₂ ⟩
        balance (txins tx ⋪ utxo) + (balance (outs tx) + txfee tx)
          ≡t⟨⟩
        balance (txins tx ⋪ utxo) + balance (outs tx) + txfee tx
          ≡˘⟨ cong (_+ txfee tx) (balance-∪ {txins tx ⋪ utxo} {outs tx} (dom-res-∩-empty (txins tx) utxo (outs tx) h)) ⟩
        balance ((txins tx ⋪ utxo) ∪ outs tx) + txfee tx ∎
    in begin
    balance utxo + fee                                        ≡⟨ cong (_+ fee) balance-eq ⟩
    balance ((txins tx ⋪ utxo) ∪ outs tx) + txfee tx + fee    ≡t⟨⟩
    balance ((txins tx ⋪ utxo) ∪ outs tx) + (txfee tx + fee)
              ≡˘⟨ cong (balance ((txins tx ⋪ utxo) ∪ outs tx) +_) (+-comm fee (txfee tx)) ⟩
    balance ((txins tx ⋪ utxo) ∪ outs tx) + (fee + txfee tx) ∎
\end{code}
\end{property}

\pagebreak
Note that this is not a function, but a relation. To make this
definition executable, we need to define a function that computes
the transition. We also prove that this indeed computes the
relation.

\begin{figure*}[h]
\begin{code}
  UTXO-step : Coin → UTxO × Coin → Tx → Maybe (UTxO × Coin)
  UTXO-step minFee (utxo , fees) tx =
    if txins tx ⊆ᵇ dom utxo
       ∧ minFee ≤ᵇ txfee tx
       ∧ balance (txins tx ◃ utxo) ≡ᵇ (balance (outs tx) + txfee tx)
      then just ((txins tx ⋪ utxo) ∪ outs tx , fees + txfee tx)
      else nothing
  
  UTXO-step-computes-UTXO :
      minFee ⊢ utxoState ⇀⦇ tx ,UTXO⦈ utxoState'
    ⇔ UTXO-step minFee utxoState tx ≡ just utxoState'
\end{code}
\caption{Computing the UTXO transition system}
\end{figure*}

We prove this by considering both cases separately. Both cases follow
easily by comparing the proof-carrying properties with the
computational properties.

\end{document}
\begin{figure*}[h]
\begin{code}[hide]
  dec-true' : ∀ {P : Set} → (p? : Dec P) → P → ⌊ p? ⌋ ≡ true
  dec-true' p? h rewrite isYes≗does p? = dec-true p? h
\end{code}
\begin{code}[hide]
  UTXO⇒UTXO-step :
      minFee ⊢ utxoState ⇀⦇ tx ,UTXO⦈ utxoState'
    → UTXO-step minFee utxoState tx ≡ just utxoState'
  UTXO⇒UTXO-step {minFee} {(utxo , _)} {tx} (UTXO-inductive h₁ h₂ h₃)
    rewrite dec-true' (txins tx ⊆? dom utxo) h₁
          | dec-true' (minFee ≤? txfee tx) h₂
          | dec-true' (balance (txins tx ◃ utxo) ≟ (balance (outs tx) + txfee tx)) h₃
          = refl
  
  UTXO-step⇒UTXO :
      UTXO-step minFee utxoState tx ≡ just utxoState'
    → minFee ⊢ utxoState ⇀⦇ tx ,UTXO⦈ utxoState'
  UTXO-step⇒UTXO {minFee} {(utxo , fees)} {tx} h
    with (txins tx) ⊆? dom utxo
       | minFee ≤? txfee tx
       | (balance (txins tx ◃ utxo) ≟ (balance (outs tx) + txfee tx))
       | h
  ... | yes p₁ | yes p₂ | yes p₃ | refl = UTXO-inductive p₁ p₂ p₃
  
  UTXO-step-computes-UTXO =
    mk⇔ UTXO⇒UTXO-step UTXO-step⇒UTXO
\end{code}
\caption{Proof of the previous claim}
\end{figure*}

\end{document}
